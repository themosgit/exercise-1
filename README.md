# exercise-1
ΥΣΒΔ
Στo hp_main.c προστέθηκε η γραμμή "remove(FILE_NAME);" μέσα στη main για να σβήνει το αρχείο που τυχόν έχει δημιουργηθεί σε προηγούμενη εκτέλεση του προγράμματος, πριν προσπαθήσει να φτιάξει καινούργιο.
Το hp_info2 μετονομάστηκε σε hp_info because ocd.
Αφαιρέθηκε το "int r;" επειδή δεν χρησιμοποιείται πουθένα because ocd.

Στο hp_file.h υλοποιήθηκαν τα struct HP_info και HP_block_info. Σημειώνεται ότι τα μέλη last_blockId και next_blockId, αντίστοιχα, μετατράπηκαν σε int από BF_Block*.

Στο hp_file.c υλοποιήθηκαν όλες οι συναρτήσεις της άσκησης. 
HP_CreateFile: Στο πρώτο block του αρχείου μπαίνει η δομή HP_info. Η τιμή max_records αντιστοιχεί στο πλήθος των records που χωράει σε ένα block και είναι ίση με (μέγεθος μπλοκ - μέγεθος struct HP_block_info)/μέγεθος struct Record.
HP_OpenFile: Ανοίγει το αρχείο και επιστρέφει HP_info*, ήτοι έναν pointer στο block 0 που έχει γίνει cast σε HP_info*. Στη συνέχει το block γίνεται destroy, το οποίο κάνει λίγο περίεργο την επιστροφή του pointer HP_info, ωστόσο, σε κάθε συνάρτηση που χρησιμοποιείται στη συνέχεια, όταν γίνεται init ένα block, το block 0 θα είναι στο ίδιο σημείο. Άρα δουλεύει με ένα μαγικό τρόπο.
HP_CloseFile: κλείνει το αρχείο. That's it.
recordBeautifier: Είναι μία συνάρτηση που υλοποιήθηκε χωρίς να ζητηθεί. Απλά μηδενίζει όλους τους αχρείαστους χαρακτήρες μέσα σε ένα Record, για να εχει καλύτερη εικόνα το τελικό αρχείο που δημιουργείται και να μην μπερδεύει το μάτι όταν το ανοίγουμε σαν κείμενο για να δούμε τα περιεχόμενά του. 
HP_InsertEntry: Το τελευταίο block του αρχείου το παίρνουμε με δύο τρόπους. Είτε με BF_GetBlockCounter, είτε από την τιμή last_blockId του HP_info. Υλοποιήθηκαν και τα δύο, ωστόσο χρησιμοποιείται το δεύτερο. Αν το αρχείο είναι άδειο (lastblockid==0) τότε δημιουργεί νέο block και κάνει το lastblockid=1. 
Όταν δημιουργείται νέο block όλα τα bit του block είναι μηδέν (όπως φαίνεται) και για τον λόγο αυτό δεν αρχικοποιείται ρητά το HP_block_info->records σε 0 (δουλεύει και αυτό με ένα μαγικό τρόπο λόγω άγνοιας υλοποίησης της βιβλιοθήκης). 
Γίνεται memcpy το Record στο block. Γίνεται dirty το block και ακολούθως destroy για να μην έχουμε memory leaks. Επιστρέφεται το lastblockid;
Σημειώνεται ότι στην περίπτωση δημιουργίας νέου block, επιπρόσθετα του dirty και destroy του νέου block, γίνεται ενημέρωση του block 0 (HP_info) και dirty (χωρίς unpin για να μην πέσει από τη μνήμη).
HP_GetAllEntries: Ψάχνει σειριακά όλα τα block του αρχείου και όλα τα records του κάθε block για να βρει την τιμη id==value. Όταν τη βρει εκτυπώνει με printrecord. Η εσωτερική λούπα ψάχνει μέχρι HP_block_info->records και όχι μέχρι HP_info->max_records, καθώς αν το id που ψάχνουμε είναι το 0 κάποιο block δεν έχει συμπληρωμένες όλες τις εγγραφές του, θα επιστρέψει και μηδενικές εγγραφές σαν να ικανοποιηούν την συνθήκη, οπότε θα τις εκτυπώσει και αυτές ως (0,,,).
Πραγματοποιήθηκε έλεγχος με valgrind και δεν υπάρχουν memory leaks, παρά μόνο ένα syscallparam warning που υπάρχει έτσι κι αλλιώς στη βιβλιοθήκη.
Εκτελέστηκε στα μηχανήματα linux της σχολής. Δοκιμάστηκε με έως 10.000.000 records.

